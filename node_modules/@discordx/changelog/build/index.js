"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDoc = exports.getRepoUrl = void 0;
const tslib_1 = require("tslib");
const lodash_1 = (0, tslib_1.__importDefault)(require("lodash"));
const child_process_1 = (0, tslib_1.__importDefault)(require("child_process"));
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const prettier_1 = (0, tslib_1.__importDefault)(require("prettier"));
const categories = [
    {
        breaking: false,
        storeTypes: ["BREAKING CHANGE"],
        title: "Breaking Changes",
    },
    { breaking: false, storeTypes: ["feat"], title: "Features" },
    { breaking: true, storeTypes: ["refactor"], title: "Changed" },
    { breaking: true, storeTypes: ["fix"], title: "Fixed" },
    { breaking: false, storeTypes: ["revert"], title: "Reverts" },
    { breaking: false, storeTypes: ["test"], title: "Tests" },
    { breaking: false, storeTypes: ["build"], title: "Build" },
    { breaking: false, storeTypes: ["types"], title: "Types" },
    { breaking: false, storeTypes: ["docs"], title: "Documenations" },
    { breaking: false, storeTypes: ["chore"], title: "Routine Tasks" },
    { breaking: false, storeTypes: ["ci", "workflow"], title: "CI" },
    { breaking: false, storeTypes: ["untagged"], title: "Untagged" },
];
function getRepoUrl() {
    let remoteurl = child_process_1.default
        .execSync("git config --get remote.origin.url")
        .toString("utf-8")
        .trim();
    if (!remoteurl.length) {
        throw Error("repo not found, make sure to run the command in the git directory only");
    }
    if (!remoteurl.endsWith(".git")) {
        remoteurl += ".git";
    }
    if (RegExp(/.*@.*:.*.git/gm).test(remoteurl)) {
        const r = RegExp(/.*@(.*?):(.*?).git/gm).exec(remoteurl);
        if (!r) {
            throw Error("Invalid repo url passed");
        }
        const domain = r.at(1);
        const subUrl = r.at(2);
        return `https://${domain}/${subUrl}`;
    }
    return remoteurl.substring(0, remoteurl.length - 4);
}
exports.getRepoUrl = getRepoUrl;
function generateDoc(options) {
    const ignoreScopes = options?.ignoreScopes
        ? options.ignoreScopes
        : [];
    const repo = getRepoUrl();
    let completeChangelog = "";
    const tags = lodash_1.default.compact(child_process_1.default
        .execSync(`git tag --list "${options?.tag?.match ?? "v*"}"`)
        .toString("utf-8")
        .split("\n"));
    tags.push("head");
    if (!tags.length) {
        throw Error("Without tags, changelogs could not be generated");
    }
    tags.forEach((tag, index) => {
        const tagString = index < 1
            ? tag
            : tag === "head"
                ? `${tags[index - 1]}..HEAD`
                : `${tags[index - 1]}..${tag}`;
        const commitsArray = child_process_1.default
            .execSync(`git log ${tagString} --format=%B----HASH----%H----DELIMITER---- ${options?.root ?? "./"}`)
            .toString("utf-8")
            .split("----DELIMITER----\n")
            .map((commit) => {
            const [message, sha] = commit.split("----HASH----");
            const title = message
                ?.split("\n")[0]
                ?.replaceAll(/#([0-9]{1,})/gm, `[#$1](${repo}/issues/$1)`);
            return {
                message: message,
                sha: (title ? sha : undefined),
                title: title,
            };
        })
            .filter((commit) => Boolean(commit.title) && Boolean(commit.sha));
        const tagDate = child_process_1.default
            .execSync(`git log -1 --format=%ai ${tag}`)
            .toString("utf-8");
        const store = [];
        commitsArray.forEach((commit) => {
            const formatedCommit = (replace) => `* ${commit.title.replace(replace ? `${replace}: ` : "", "")} ([${commit.sha.substring(0, 6)}](${repo}/commit/${commit.sha}))\n`;
            let isPushed = false;
            categories.forEach((cat) => {
                cat.storeTypes.forEach((st) => {
                    if (commit.title.startsWith(`${st}: `)) {
                        store.push({
                            text: formatedCommit(st),
                            type: commit.message.includes("BREAKING CHANGE")
                                ? "BREAKING CHANGE"
                                : st,
                        });
                        isPushed = true;
                    }
                });
            });
            if (!isPushed) {
                store.push({ text: formatedCommit(), type: "untagged" });
            }
        });
        let finalChangeLog = tag === "head"
            ? options?.header ?? "# Stage\n\n"
            : `# [${tag}](${repo}/releases/tag/${tag}) (${new Date(tagDate).toISOString().split("T")[0]})\n\n`;
        if (options?.tag?.replace) {
            finalChangeLog = finalChangeLog.replace(options.tag.replace, "");
        }
        categories.forEach((cat) => {
            const items = store.filter((r) => cat.storeTypes.includes(r.type) && !ignoreScopes.includes(r.type));
            if (items.length) {
                finalChangeLog += `## ${cat.title}\n`;
                items.forEach((cm) => {
                    finalChangeLog += cm.text;
                });
                finalChangeLog += "\n";
            }
        });
        finalChangeLog += "\n";
        completeChangelog = finalChangeLog + completeChangelog;
    });
    fs_1.default.writeFileSync(options?.outDir ?? "./CHANGELOG.md", `${prettier_1.default.format(completeChangelog, {
        parser: "markdown",
    })}`);
    return repo;
}
exports.generateDoc = generateDoc;
//# sourceMappingURL=index.js.map