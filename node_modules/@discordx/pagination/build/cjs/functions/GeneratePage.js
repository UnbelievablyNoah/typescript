"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratePage = void 0;
const discord_js_1 = require("discord.js");
const types_js_1 = require("../types.js");
const paginate_js_1 = require("./paginate.js");
const GeneratePage = (item, page, totalPages, option) => {
    const beginning = page === 0;
    const end = page === totalPages - 1;
    const newMessage = typeof item === "string"
        ? { content: item }
        : item instanceof discord_js_1.MessageEmbed
            ? { embeds: [item] }
            : item;
    if (option.type === "BUTTON") {
        const startBtn = new discord_js_1.MessageButton()
            .setCustomId(option.start?.id ?? types_js_1.defaultIds.buttons.start)
            .setLabel(option.start?.label ?? "Start")
            .setStyle(option.start?.style ?? "PRIMARY")
            .setDisabled(beginning);
        const endBtn = new discord_js_1.MessageButton()
            .setCustomId(option.end?.id ?? types_js_1.defaultIds.buttons.end)
            .setLabel(option.end?.label ?? "End")
            .setStyle(option.end?.style ?? "PRIMARY")
            .setDisabled(end);
        const nextBtn = new discord_js_1.MessageButton()
            .setCustomId(option.next?.id ?? types_js_1.defaultIds.buttons.next)
            .setLabel(option.next?.label ?? "Next")
            .setStyle(option.next?.style ?? "PRIMARY")
            .setDisabled(end);
        const prevBtn = new discord_js_1.MessageButton()
            .setCustomId(option.previous?.id ?? types_js_1.defaultIds.buttons.previous)
            .setLabel(option.previous?.label ?? "Previous")
            .setStyle(option.previous?.style ?? "PRIMARY")
            .setDisabled(beginning);
        const exitBtn = new discord_js_1.MessageButton()
            .setCustomId(option.exit?.id ?? types_js_1.defaultIds.buttons.exit)
            .setLabel(option.exit?.label ?? "Exit")
            .setStyle(option.exit?.style ?? "DANGER");
        // set emoji
        if (option.start?.emoji) {
            startBtn.setEmoji(option.start.emoji);
        }
        if (option.end?.emoji) {
            endBtn.setEmoji(option.end.emoji);
        }
        if (option.next?.emoji) {
            nextBtn.setEmoji(option.next.emoji);
        }
        if (option.previous?.emoji) {
            prevBtn.setEmoji(option.previous.emoji);
        }
        if (option.exit?.emoji) {
            exitBtn.setEmoji(option.exit.emoji);
        }
        const buttons = [prevBtn, nextBtn];
        if (totalPages > 10 && (option.showStartEnd ?? true)) {
            buttons.unshift(startBtn);
            buttons.push(endBtn);
        }
        if (option.enableExit) {
            buttons.push(exitBtn);
        }
        const row = new discord_js_1.MessageActionRow().addComponents(buttons);
        // reset message payload additional parameters
        if (!newMessage.embeds) {
            newMessage.embeds = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.attachments) {
            newMessage.attachments = [];
        }
        return { newMessage, paginationRow: row };
    }
    else {
        const paginator = (0, paginate_js_1.paginate)(totalPages, page, 1, 21).pages.map((i) => {
            // const selectMenuOption: MessageSelectOptionData = {
            const selectMenuOption = {
                label: ((option.pageText instanceof Array
                    ? option.pageText[i - 1]
                    : option.pageText) ?? "Page {page}").replaceAll("{page}", `${i}`),
                value: (i - 1).toString(),
            };
            return selectMenuOption;
        });
        if (totalPages > 21 && (option.showStartEnd ?? true)) {
            if (page > 10) {
                paginator.unshift({
                    label: option.labels?.start ?? "Start",
                    value: "-1",
                });
            }
            if (page < totalPages - 10) {
                paginator.push({ label: option.labels?.end ?? "End", value: "-2" });
            }
        }
        if (option.enableExit) {
            paginator.push({
                label: option.labels?.exit ?? "Exit Pagination",
                value: "-3",
            });
        }
        const menu = new discord_js_1.MessageSelectMenu()
            .setCustomId(option.menuId ?? types_js_1.defaultIds.menu)
            .setPlaceholder(option.placeholder ?? "Select page")
            .setOptions(paginator);
        const row = new discord_js_1.MessageActionRow().addComponents([menu]);
        // reset message payload additional parameters
        if (!newMessage.embeds) {
            newMessage.embeds = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.attachments) {
            newMessage.attachments = [];
        }
        return { newMessage, paginationRow: row };
    }
};
exports.GeneratePage = GeneratePage;
//# sourceMappingURL=GeneratePage.js.map