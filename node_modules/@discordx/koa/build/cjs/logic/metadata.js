"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataStorage = void 0;
const internal_1 = require("@discordx/internal");
const di_1 = require("@discordx/di");
class MetadataStorage {
    // internal
    static _isBuilt = false;
    static _instance;
    _modifiers = [];
    // storage
    _routers = [];
    _routes = [];
    // internal getters
    static get instance() {
        if (!this._instance) {
            this._instance = new MetadataStorage();
        }
        return this._instance;
    }
    static set instance(value) {
        this._instance = value;
    }
    static get isBuilt() {
        return this._isBuilt;
    }
    // storage getter
    get routers() {
        return this._routers;
    }
    get routes() {
        return this._routes;
    }
    // methods
    addRouter(router) {
        this._routers.push(router);
        di_1.DIService.instance.addService(router.classRef);
    }
    addRequest(route) {
        this._routes.push(route);
    }
    addModifier(modifier) {
        this._modifiers.push(modifier);
    }
    async build(koa) {
        // build the instance if not already built
        if (MetadataStorage.isBuilt) {
            return;
        }
        MetadataStorage._isBuilt = true;
        await internal_1.Modifier.applyFromModifierListToList(this._modifiers, this._routers);
        await internal_1.Modifier.applyFromModifierListToList(this._modifiers, this._routes);
        this.routers.forEach((r) => {
            this.routes.forEach((route) => {
                if (route.from === r.from) {
                    route.router = r;
                    // register if filter is valid
                    const api = route.api ?? r.api;
                    if (!api || koa.api === api) {
                        this.registerRoute(koa, r, route);
                    }
                }
            });
            koa.use(r.router.routes());
        });
    }
    registerRoute(koa, router, route) {
        switch (route.type) {
            case "ALL":
                router.router.all(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "DELETE":
                router.router.delete(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "GET":
                router.router.get(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "HEAD":
                router.router.head(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "LINK":
                router.router.link(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "OPTIONS":
                router.router.options(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "PATCH":
                router.router.patch(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "POST":
                router.router.post(route.path, ...route.middlewares, route.handler(koa));
                break;
            case "UNLINK":
                router.router.unlink(route.path, ...route.middlewares, route.handler(koa));
                break;
            default: {
                throw Error("Attempted to register an invalid method");
            }
        }
    }
}
exports.MetadataStorage = MetadataStorage;
//# sourceMappingURL=metadata.js.map